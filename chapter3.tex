\chapter{Kapitel III - NoSQL - Ausgewählte Systeme Unboxed}
\setcounter{section}{7}
\section{ArangoDB}
ArangoDB ist gehört zu den \ac{NoSQL} Datenbanken. Die Datenbank ist besonders bekannt für ihr Multi-Model. Multi-Modell bedeutet, dass eine \ac{DBS} mehrere Datenmodelle besitzt. Welche diese sind und wie ArangoDB funktioniert und aufgebaut ist, wird in diesen Kapitel gezeigt und erklärt.
\subsection{Anwendungsumfeld}
In vielen Projekten steht am Anfang nicht fest welches \ac{DBS} das beste für sie sei. Jede Datenbank bringt seine eigenen Vorteile und Nachteile mit sich. Und genau an dieser Stelle spielt ArangoDB eine wichtige Rolle. 

Durch sein 'natives' Multi-Modell ermöglicht es Vor- und Nachteil von Datenbankmodell auszugleichen. Dadurch wird ArangoDB zur 'Multi-Purpose-Datenbank' mit einem soliden Dokumenten Basismodell \citep{jaxenter01}. Bei einer agilen Vorgehensweise mit stetig wechselenden Anforderungen, kann es Vorteilhaft sein ein ebenso flexibles \ac{DBS} wie ArangoDB zu haben. 

 \subsection{Technologische Aspekte}
Wie schon im Kapitel davor angeschnitten, ist der Kern der ArangoDB sein vielseitiges Multi-Modell. Insgesamt besteht dies aus drei verschiedenen Datenbank-Modellen, welche zu einem vereint und je nach Anwendungsfall 
eingesetzt werden kann.
Das Multi-Modell besteht aus diesen vereineten Datenbankmodellen:
\paragraph{Dokumentenbasiertes Modell} Das dokumentbasierte Modell dient als solide Basis für das \ac{DBS}. Im Modell wird \ac{JSON} als Speicherformat verwendet. Durch seine Semi-Struktur und hirarschichen Aufbau ist  ein dokumentenbasiertes Modell perfekt für viele Anwendungsfälle\cite{AWS_doc}.  Außerdem bietet es eine gute Grundlage für die beiden anderen Datenmodelle.
\paragraph{Graphbasiertes Modell} Ein Graphmodell bietet die Möglichkeit Beziehungen zwischen Objekten im dokumentenbasierten Modell abzubilden. Außerdem hilft das graphbasierte Modell Datenstrukturen leichter zu verstehen und JOINs schneller abzubilden \cite{AWS_graph}.Des Weiteren können sogennante Super-Nodes identifiziert und anschließen optimiert werden, damit Zugriffe auf diese Objekte performanter ist.
\paragraph{Key-Value-Modell} Das Key-Value-Modell ist dafür optimiert Objekte zu einen gewissen Schlüssel schell abzurufen. Anstatt lange Querys zu schreiben zu müssen, hilft das Key-Value-Modell optimiert auf diese Werte zuzugreifen. Der Vorteil hier ist, dass durch den geschaffenen Index die Datensätze gut partitioniert werden können. \cite{AWS_keyvalue}

Zusammenfassend kann man also sagen, dass ArangoDB durch die Kombination der drei Datenbankmodellen ein perfektes Modell für fast jeden Anwendungsfall parat hat. Jedoch hat natürlich auch die Vereinigung der Modelle Nachteile. ArangoDB bietet zwar dem Nutzer das passende Modell für seinen Anwendungsfall, jedoch hat die Datenbank keine Chance gegenüber der Performance von Datenbanken, die diese Modelle nativ implementieren \cite{ADB_benchmark}.
\subsubsection{Systemarchitektur}
ArangoDB im Clusterbetrieb erfüllt das "CP" des CAP-Theorems \cite{CAP}. Mit seinem Prinzip des 'Master/Master'-Ansatzes ermöglicht es eine hohe Partitionsmöglichkeit und liefert wenn immer die aktuellsten Daten zurück. Ermöglicht wird dies durch die Bereitstellung der drei verschiedenen Komponenten im Clusterbetrieb \cite{ADB_clusterarch}:
\paragraph{Agententen} 
Beeinhalten die Konfiguration des Clusters. Agenten wissen wie viele DB-Server im Cluster verfügbar sind, wo sich diese befinden und welche Daten diese enthalten. Außerdem kümmern sie sich im synchronität der verschiedenen Datenbankinstanzen im Cluster. Demnach führen diese Komponenten auch Transaktionen auf dem Datenbankcluster aus. Von dem ArangoDB-Team werden Agenten auch als Herz des Clusters bezeichnet. \cite{ADB_clusterarch}
\paragraph{Koordinatoren}
Koordinatoren bilden die Schnittstelle zum Cluster dar. Sie kümmern sich um Abfragen mit \ac{AQL} an die Datenbanken oder aber auch implementieren Foxx Microservices in ihrer Architektur. Sie wissen welcher der optimalste Weg für die Datenabfrage ist und sammeln sich so die Daten von verschiedenen Datenbankservern zusammen. Da Koordinatoren zustandlos sind, können diese sehr schnell zu einen bestehen Cluster hinzugefügt werden und so Anfrageengpässe verhindern. \cite{ADB_clusterarch}
\paragraph{DB-Server} 
Diese Komponente im Cluster ist für die eigentliche Datenspeicherung zuständig. An diese Komponente stellen die Koordinatoren ihre Datenabfragen. Bei Datenänderungen werden zunächste die Daten der Hauptdatenbank geändert, um anschließend synchron die Follow-Datenbanken zu aktualisieren.

Das Gesamtbild der Architektur lässt sich gut mit Abbildung \ref{fig:ClusterArch} zusammenfassen:
\begin{figure}[htbp] 
  	\centering
     \includegraphics[width=1\textwidth]{./images/cluster-arch.png}
 	\caption{ArangoDB Cluster Architektur \cite{ADB_clusterarch}}
  \label{fig:ClusterArch}
\end{figure}


\subsubsection{Programmierschnittstellen}
Bei den Zugriffmöglichkeiten auf die Daten bietet ArangoDB eine Vielzahl von Möglichkeiten.

Eine Möglichkeit sind Treiber für verschiedene Programmiersprachen wie Java, NodeJS, PHP und viele andere. Des Weiteren gibt es auch viele Treiber, die von der ArangoDB Community zur Verfügung gestellt werden. \cite{ADB_driver} Diese Führen dann mit \ac{AQL} Datenabfragen auf dem Cluster. 

Eine weitere Möglichkeit ist das mitgelieferte \ac{CLI}-Tool 'arangosh'. Ein sehr gutes Tool um schnelle Testabfragen an das Datenbanksystem zu machen, jedoch ungeeignet für Produktivsysteme. \cite{ADB_arangosh}

Als letzte Zugriffsmöglichkeit bietet ArangoDB eine \ac{API}. Mit ihr können zum Beispiel Collections, Datenbanken und Kanten über \ac{HTTP} abgefragt werden. \cite{ADB_api} Allerdings ist diese \ac{API} auch noch erweiter, um sogennante Foxx-Microservices, diese in das Datenbanksystem mittels Javascript deployt werden können. Die Microservices dienen dem Nutzer der Datenbank komplexere Berechnungen oder Abfragen datenbanknahme und optimiert ausführen zu können. \cite{ADB_foxx}

\subsubsection{Physische Strukturen}
\subsubsection{Transaktionsunterstützung}

\subsection{Datenbankentwicklung}
\subsubsection{Systeminstallation}
\subsubsection{Datenmodellierung und Beispielschema}
\subsubsection{Import der Beispieldaten}
\subsubsection{AdHoc-Anfragen}