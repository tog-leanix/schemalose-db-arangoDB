\chapter{Kapitel III - NoSQL - Ausgewählte Systeme Unboxed}
\setcounter{section}{7}
\section{ArangoDB}
ArangoDB ist gehört zu den \ac{NoSQL} Datenbanken. Die Datenbank ist besonders bekannt für ihr Multi-Modell. Multi-Modell bedeutet, dass ein \ac{DBS} mehrere Datenmodelle besitzt. Welche diese sind und wie ArangoDB funktioniert und aufgebaut ist, wird in diesen Kapitel gezeigt und erklärt.
\subsection{Anwendungsumfeld}
In vielen Softwareprojekten steht am Anfang nicht fest welches \ac{DBS} das beste für sie sei. Jede Datenbank bringt seine eigenen Vorteile und Nachteile mit sich. Und genau an dieser Stelle spielt ArangoDB eine wichtige Rolle.
Durch sein ’natives’ Multi-Modell ermöglicht es die Vor- und Nachteile von Datenbankmodellen auszugleichen. Dadurch wird ArangoDB zur ’Multi-Purpose-Datenbank’ mit einem dokumentenbasierten Basismodell\cite{jaxenter01}. Es kann bei einer agilen Vorgehensweise mit stetig wechselnden Anforderungen sehr Vorteilhaft sein, ein ebenso flexibles DBS wie ArangoDB zu verwenden.

 \subsection{Technologische Aspekte}
Der Kern der ArangoDB ist sein vielseitiges Multi-Modell, welches insgesamt aus drei verschiedenen Datenbank-Modellen besteht. Diese sind zu einem Modell vereint und können je nach Anwendungsfall eingesetzt werden. Das Multi-Modell besteht aus folgenden  vereinten Datenbankmodellen:

\paragraph{Das dokumentbasierte Modell} dient als solide Basis für das \ac{DBS}. Im Modell wird \ac{JSON} als Speicherformat verwendet. Durch seine Semi-Struktur und hirarschichen Aufbau ist  ein dokumentenbasiertes Modell ideal für viele Anwendungsfälle geeignet\cite{AWS_doc}.  Außerdem bietet es eine gute Grundlage für die beiden anderen Datenmodelle.

\paragraph{Das graphbasiertes Modell} bietet die Möglichkeit Beziehungen zwischen Objekten im dokumentenbasierten Modell abzubilden. Außerdem hilft das graphbasierte Modell Datenstrukturen leichter zu verstehen und JOINs schneller aufzulösen \cite{AWS_graph}. Des Weiteren können sogennante Super-Nodes identifiziert und anschließen optimiert werden, damit der Zugriff auf diese Objekte performanter ist.

\paragraph{Das Key-Value-Modell} ist dafür optimiert Objekte zu einen gewissen Schlüssel schell abzurufen.  Anstatt lange Querys schreiben zu müssen, hilft das Key-Value-Modell optimiert auf diese Werte zuzugreifen. Optimal partitionierte Datensätze durch den geschaffenen Index sind dabei ein großer Vorteil. \cite{AWS_keyvalue}

Zusammenfassend kann man sagen, dass ArangoDB durch die Kombination der drei Datenbankmodellen ein perfektes Modell für fast jeden Anwendungsfall vorweist. Allerdings hat die Vereinigung der Modelle auch Nachteile. ArangoDB bietet zwar dem Nutzer das passende Modell für seinen Anwendungsfall, hat jedoch keine Chance gegenüber der Performance von Datenbanken, die diese Modelle nativ implementieren \cite{ADB_benchmark}.

\subsubsection{Systemarchitektur}
ArangoDB im Clusterbetrieb erfüllt das "CP" des CAP-Theorems \cite{CAP}. Mit seinem Prinzip des 'Master/Master'-Ansatzes ermöglicht es eine hohe Partitionsmöglichkeit und liefert wenn immer die aktuellsten Daten zurück. Ermöglicht wird dies durch die Bereitstellung der drei verschiedenen Komponenten im Clusterbetrieb \cite{ADB_clusterarch}:
\paragraph{Agententen} 
Beeinhalten die Konfiguration des Clusters. Agenten wissen wie viele DB-Server im Cluster verfügbar sind, wo sich diese befinden und welche Daten diese enthalten. Außerdem kümmern sie sich im synchronität der verschiedenen Datenbankinstanzen im Cluster. Demnach führen diese Komponenten auch Transaktionen auf dem Datenbankcluster aus. Von dem ArangoDB-Team werden Agenten auch als Herz des Clusters bezeichnet. \cite{ADB_clusterarch}
\paragraph{Koordinatoren}
Koordinatoren bilden die Schnittstelle zum Cluster dar. Sie kümmern sich um Abfragen mit \ac{AQL} an die Datenbanken oder aber auch implementieren Foxx Microservices in ihrer Architektur. Sie wissen welcher der optimalste Weg für die Datenabfrage ist und sammeln sich so die Daten von verschiedenen Datenbankservern zusammen. Da Koordinatoren zustandlos sind, können diese sehr schnell zu einen bestehen Cluster hinzugefügt werden und so Anfrageengpässe verhindern. \cite{ADB_clusterarch}
\paragraph{DB-Server} 
Diese Komponente im Cluster ist für die eigentliche Datenspeicherung zuständig. An diese Komponente stellen die Koordinatoren ihre Datenabfragen. Bei Datenänderungen werden zunächste die Daten der Hauptdatenbank geändert, um anschließend synchron die Follow-Datenbanken zu aktualisieren.

Das Gesamtbild der Architektur lässt sich gut mit Abbildung \ref{fig:ClusterArch} zusammenfassen:
\begin{figure}[htbp] 
  	\centering
     \includegraphics[width=1\textwidth]{./images/cluster-arch.png}
 	\caption{ArangoDB Cluster Architektur \cite{ADB_clusterarch}}
  \label{fig:ClusterArch}
\end{figure}


\subsubsection{Programmierschnittstellen}
Bei den Zugriffmöglichkeiten auf die Daten bietet ArangoDB eine Vielzahl von Möglichkeiten.

Eine Möglichkeit sind Treiber für verschiedene Programmiersprachen wie Java, NodeJS, PHP und viele andere. Des Weiteren gibt es auch viele Treiber, die von der ArangoDB Community zur Verfügung gestellt werden. \cite{ADB_driver} Diese Führen dann mit \ac{AQL} Datenabfragen auf dem Cluster. 

Eine weitere Möglichkeit ist das mitgelieferte \ac{CLI}-Tool 'arangosh'. Ein sehr gutes Tool um schnelle Testabfragen an das Datenbanksystem zu machen, jedoch ungeeignet für Produktivsysteme. \cite{ADB_arangosh}

Als letzte Zugriffsmöglichkeit bietet ArangoDB eine \ac{API}. Mit ihr können zum Beispiel Collections, Datenbanken und Kanten über \ac{HTTP} abgefragt werden. \cite{ADB_api} Allerdings ist diese \ac{API} auch noch erweiter, um sogennante Foxx-Microservices, diese in das Datenbanksystem mittels Javascript deployt werden können. Die Microservices dienen dem Nutzer der Datenbank komplexere Berechnungen oder Abfragen datenbanknahme und optimiert ausführen zu können. \cite{ADB_foxx}

\subsubsection{Physische Strukturen}
\subsubsection{Transaktionsunterstützung}

\subsection{Datenbankentwicklung}
\subsubsection{Systeminstallation}
\subsubsection{Datenmodellierung und Beispielschema}
\subsubsection{Import der Beispieldaten}
\subsubsection{AdHoc-Anfragen}